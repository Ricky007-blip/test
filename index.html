<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Photo Measure Tool</title>
  <style>
    canvas {
      border: 1px solid #ccc;
      cursor: crosshair;
      max-width: 100%;
      height: auto;
    }
    #output {
      margin-top: 10px;
    }
    .flash {
      background-color: #4CAF50 !important;
      transition: background-color 0.2s;
    }
  </style>
</head>
<body>
  <h2>Measure From Image</h2>
  <input type="file" id="upload" accept="image/*" capture="environment" style="display: none;">
  <button id="loadPhotoBtn">Load Photo</button>
  <br><br>
  <button id="okBtn" disabled>OK</button>
  <button id="doneBtn" disabled>DONE</button>
  <button id="redoBtn">REDO</button>
  <br><br>
  <canvas id="canvas"></canvas>
  <div id="output"></div>
  <ul id="areaList"></ul>

  <script>
    const upload = document.getElementById('upload');
    const loadPhotoBtn = document.getElementById('loadPhotoBtn');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const output = document.getElementById('output');
    const okBtn = document.getElementById('okBtn');
    const doneBtn = document.getElementById('doneBtn');
    const redoBtn = document.getElementById('redoBtn');
    const areaList = document.getElementById('areaList');

    let img = new Image();
    let clickPoints = [];
    let scaleRatio = null;
    let rectangles = [];
    let rectStart = null;
    let rectPreview = null;
    let isDrawing = false;
    let mode = 'wall';

    document.addEventListener('DOMContentLoaded', () => {
      loadPhotoBtn.addEventListener('click', () => {
        loadPhotoBtn.classList.add('flash');
        setTimeout(() => loadPhotoBtn.classList.remove('flash'), 200);
        try {
          upload.click();
        } catch (err) {
          alert("Could not open file selector. Please allow access to media/photos in your browser settings.");
        }
      });
    });

    upload.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function (event) {
        img.onload = function () {
          canvas.width = img.width;
          canvas.height = img.height;
          ctx.drawImage(img, 0, 0);
          resetTool();
          output.innerHTML = 'Click two points (e.g. known width), then input actual length.';
        };
        img.src = event.target.result;
      };
      reader.readAsDataURL(file);
    });

    canvas.addEventListener('mousedown', (e) => {
      const pos = getMousePos(e);
      if (!scaleRatio) {
        clickPoints.push(pos);
        drawAll();
        if (clickPoints.length === 2) {
          drawAll();
          setTimeout(() => {
            const dist = getDistance(clickPoints[0], clickPoints[1]);
            const realLength = prompt("Enter the actual length between these two points (in cm):");
            if (realLength && !isNaN(realLength)) {
              scaleRatio = realLength / dist;
              clickPoints = [];
              output.innerHTML = `Scale set: 1 pixel = ${scaleRatio.toFixed(4)} cm. Now draw rectangle of the wall.`;
              okBtn.disabled = false;
              doneBtn.disabled = false;
              drawAll();
            }
          }, 10);
        }
      } else {
        rectStart = pos;
        isDrawing = true;
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      if (!isDrawing || !rectStart) return;
      const current = getMousePos(e);
      rectPreview = {
        x: Math.min(rectStart.x, current.x),
        y: Math.min(rectStart.y, current.y),
        width: Math.abs(current.x - rectStart.x),
        height: Math.abs(current.y - rectStart.y)
      };
      drawAll();
    });

    canvas.addEventListener('mouseup', () => {
      isDrawing = false;
    });

    okBtn.addEventListener('click', () => {
      if (rectPreview && scaleRatio) {
        rectangles.push({ ...rectPreview, type: mode });
        const areaCm2 = (rectPreview.width * scaleRatio) * (rectPreview.height * scaleRatio);
        const areaM2 = areaCm2 / 10000;
        const label = mode === 'wall' ? 'Wall' : 'Opening';
        const li = document.createElement('li');
        li.textContent = `${label}: ${areaM2.toFixed(2)} m²`;
        areaList.appendChild(li);
        drawAll();
        rectPreview = null;
        rectStart = null;
        if (mode === 'wall') {
          mode = 'opening';
          output.innerHTML = 'Draw rectangle of each window or door on the wall and press OK. Press DONE-button after the last window or door.';
        }
      }
    });

    doneBtn.addEventListener('click', () => {
      const wall = rectangles.find(r => r.type === 'wall');
      const openings = rectangles.filter(r => r.type === 'opening');
      const wallArea = (wall.width * scaleRatio) * (wall.height * scaleRatio);
      const openingsArea = openings.reduce((sum, r) => sum + (r.width * scaleRatio) * (r.height * scaleRatio), 0);
      const paintable = wallArea - openingsArea;
      output.innerHTML = `Total paintable area: ${(paintable / 10000).toFixed(2)} m²`;
    });

    redoBtn.addEventListener('click', () => {
      if (!scaleRatio && clickPoints.length > 0) {
        clickPoints.pop();
      } else if (rectPreview || rectangles.length > 0) {
        if (rectPreview) {
          rectPreview = null;
          rectStart = null;
        } else {
          rectangles.pop();
          areaList.removeChild(areaList.lastChild);
        }
      }
      drawAll();
    });

    function drawAll() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(img, 0, 0);

      if (!scaleRatio && clickPoints.length > 0) {
        ctx.fillStyle = 'red';
        clickPoints.forEach(p => {
          ctx.beginPath();
          ctx.arc(p.x, p.y, 5, 0, 2 * Math.PI);
          ctx.fill();
        });
      }

      rectangles.forEach(rect => {
        ctx.strokeStyle = rect.type === 'wall' ? 'green' : 'blue';
        ctx.lineWidth = 2;
        ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
      });

      if (rectPreview) {
        ctx.strokeStyle = 'blue';
        ctx.lineWidth = 1;
        ctx.setLineDash([6]);
        ctx.strokeRect(rectPreview.x, rectPreview.y, rectPreview.width, rectPreview.height);
        ctx.setLineDash([]);
      }
    }

    function getDistance(p1, p2) {
      const dx = p2.x - p1.x;
      const dy = p2.y - p1.y;
      return Math.sqrt(dx * dx + dy * dy);
    }

    function getMousePos(evt) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: evt.clientX - rect.left,
        y: evt.clientY - rect.top
      };
    }

    function resetTool() {
      clickPoints = [];
      scaleRatio = null;
      rectangles = [];
      drawingRect = false;
      rectStart = null;
      rectPreview = null;
      isDrawing = false;
      mode = 'wall';
      okBtn.disabled = true;
      doneBtn.disabled = true;
      areaList.innerHTML = '';
    }
  </script>
</body>
</html>
